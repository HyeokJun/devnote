extends layout

block content
  header
    div.page-header
      h1= title

  div.row-fluid
      div.span5.writer
          form(method="post", id='newpost', action="/wikis/note/pages")
            fieldset
              div.control-group
                label(name="name").control-label title
                div.controls
                  input(id="title", name="name").input-xlarge.title
              div.control-group
                label(name="body").control-label body
                div.controls
                  textarea(id="body", name="body", rows="15").input-xlarge.textbody
              div
                input(type="submit", value="새 페이지 등록").btn-primary
  div#message.alert.alert-error
  script(type="text/javascript", src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.js")
  script(type="text/javascript", src="http://malsup.github.com/jquery.form.js")
  script(src="/socket.io/socket.io.js")

  script

  script
    var pageId;
    $(function(){
      var socket = io.connect();
      socket.on('connected', function(id){
        pageId = id;
      });
      socket.on('dupped', function(data){
        alert('dupped' + data.id);
      });

      $('#title').keyup(function(){
        debounce(function(){
          var title = $('#title').val();
          $('#message').html(title);
          socket.emit('page name changed', {name: title, id: pageId, user: {id: 'doortts', email: 'doortts@gmail.com'}});
        }, 500);
      });
    });
  script
    // 일정 시간 이내의 호출은 캔슬하고 처음 호출만 살림
    // _.defer 호환
    var deferTime;
    var defer = function(callback, timeout){
      if (deferTime === undefined){
        setTimeout(callback, timeout);
        setTimeout(function(){
          deferTime = undefined;
        }, timeout);
        deferTime = Math.round((new Date()).getTime() / 1000);
        return;
      }
      var now = Math.round((new Date()).getTime() / 1000);
      var timeoutId = setTimeout(callback, timeout);
      if ( now < deferTime + timeout ){
        clearTimeout(timeoutId)
      }
    }

    // 일정 시간 이내의 call은 캔슬하고 마지막 콜만 남김
    // _.debounce 호환
    var debounceTime, lastCall;
    var debounce = function(callback, waitTime){
      var now = Math.round((new Date()).getTime() / 1000);
      if (debounceTime === undefined){
        lastCall = setTimeout(callback, waitTime);
        debounceTime = now;
        return;
      }
      if ( now < debounceTime + waitTime ){
        debounceTime = now;
        clearTimeout(lastCall);
        lastCall = setTimeout(function(){
          callback();
          debounceTime = undefined;
        }, waitTime);
      }
    }
